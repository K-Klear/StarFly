go.property("crew", 0)
go.property("level", 0)
SHIP = require("main.ship.ship_layout")

local function getClosestLadder(target_level, self)
	local dist = 1/0
	local best
	if self.level ~= 2 then target_level = 2 end
	for key, val in ipairs(SHIP.LADDERS) do
		if val.level == self.level and val.target == target_level then
			local distance = math.abs(val.x - go.get_position().x)
			if distance < dist then
				best = val
				dist = distance
			end
		end
	end
	return best
end


local function walk(self)
	if SHIP[self.destination].level == self.level then
		if go.get_position().x == SHIP[self.destination].x then
			for key, val in ipairs(self.sprite_parts) do
				if key == 5 then
					sprite.play_flipbook("#hair", "idle_"..val)
				else
					sprite.play_flipbook("#"..val, val.."_idle")
				end
			end
		else
			local flip = go.get_position().x < SHIP[self.destination].x
			for key, val in ipairs(self.sprite_parts) do
				if key == 5 then
					sprite.play_flipbook("#hair", "walk_"..val)
					sprite.set_hflip("#hair", flip)
				else
					sprite.play_flipbook("#"..val, val.."_walk")
					sprite.set_hflip("#"..val, flip)
				end
			end
			local duration = math.abs(SHIP[self.destination].x - go.get_position().x) * 0.02
			go.animate(go.get_id(), "position.x", go.PLAYBACK_ONCE_FORWARD, SHIP[self.destination].x, go.EASING_LINEAR, duration, 0, walk)
		end
	else
		local ladder = getClosestLadder(SHIP[self.destination].level, self)
		if go.get_position().x == ladder.x then
			go.animate(go.get_id(), "position.y", go.PLAYBACK_ONCE_FORWARD, (ladder.target * 96) - 128, go.EASING_LINEAR, 1.72, 0, walk)
			self.level = ladder.target
		else
			local flip = go.get_position().x < ladder.x
			for key, val in ipairs(self.sprite_parts) do
				if key == 5 then
					sprite.play_flipbook("#hair", "walk_"..val)
					sprite.set_hflip("#hair", flip)
				else
					sprite.play_flipbook("#"..val, val.."_walk")
					sprite.set_hflip("#"..val, flip)
				end
			end
			local duration = math.abs(ladder.x - go.get_position().x) * 0.02
			go.animate(go.get_id(), "position.x", go.PLAYBACK_ONCE_FORWARD, ladder.x, go.EASING_LINEAR, duration, 0, walk)
		end
	end
end

local function get_crew_ID()
	for key, val in ipairs(crew) do
		if val.go == go.get_id() then
			return key
		end
	end
	return nil
end

function init(self)
	local crewID = get_crew_ID()
	self.sprite_parts = {"hand", "head", "legs", "torso", crew[crewID].face.hair}
	go.set_parent(go.get_id(), "/ship")
	sprite.set_constant("#hand", "tint", crew[crewID].face.skinTone)
	sprite.set_constant("#head", "tint", crew[crewID].face.skinTone)
	sprite.set_constant("#hair", "tint", crew[crewID].face.hairColor)
	sprite.set_constant("#torso", "tint", crew[crewID].face.clothesColor)
	sprite.set_constant("#legs", "tint", crew[crewID].face.clothesColor - vmath.vector4(0.1, 0.1, 0.1, 0))
	sprite.play_flipbook("#hair", "idle_"..crew[crewID].face.hair)
end


function on_message(self, message_id, message, sender)
	if message_id == hash("move") then
		self.destination = message.target
		walk(self)
	elseif message_id == hash("die") then
		self.deleted = true
		go.delete()
	end
end

function update(self, dt)
	if not self.deleted then
		msg.post("/main#interface", "update_position", {pos = go.get_world_position(), crew = get_crew_ID()})
	end
end